---
title: 算法导论6-4
categories: algorithms
---

## 读书笔记

之前说过降序数组都是最大堆，但是反之不然，本小节讲述的是从最大堆中获取降序数组的过程；

伪代码如下：

```python
HEAPSORT(A)
	BUILD-MAX-HEAP(A)
	for i = A.length downto 2
		exchange A[1] with A[i]
		A.heap-size = A.heap - 1
		MAX-HEAPIFY(A,1)
```

通过不断获取剩余数组中的最大值来获取排序数组；

## 课后习题

### 6.4-1

> 参照图6-4的方法，说明$HEAPSORT$在数组$A=<5,13,2,25,7,17,20,8,4>$上的操作过程。

根据伪代码足以操作，略。

### 6.4-2

> 试分析在使用下列循环不变量时，$HEAPSORT$的正确性：
>
> > 在算法的第2~5行for循环每次迭代开始时，子数组$A[1..i]$是一个包含了数组$A[1..n]$中第$i$个小元素的最大堆，而子数组$A[i+1..n]$包含了数组$A[1..n]$中已排除的$n-i$个最大元素？

__子数组$A[1..i]$是一个包含了数组$A[1..n]$中第$i$个小元素的最大堆__:

在上一次迭代最后调用了$MAX-HEAPIFY(A, 1)$，将$A[1..n]$变成了一个最大堆；

__子数组$A[i+1..n]$包含了数组$A[1..n]$中已排除的$n-i$个最大元素__:

每次迭代都会选出当前剩余数组中的最大值，迭代次数为$n-i$，所以上述语句成立。

### 6.4-3

> 对于一个升序排列的包含$n$个元素的有序数组$A$来说，$HEAPSORT$的时间复杂度是多少？如果$A$是降序呢？

$HEAPSORT$将会选出一个降序的数组，所以当一个数组为升序时，处于最坏情况，时间复杂度为$\Omega(n\lg{n})$；

当一个数组为降序时，时间复杂度为$\theta(n)$；

### 6.4-4

> 证明： 在最坏情况下， $HEAPSORT$的时间复杂度是$\Omega(n\lg{n})$。

最坏情况也就是所有情况都走一遍，首先$BUILD-MAX-HEAP$的时间复杂度为$O(n\lg{n})$，

其次下面的循环为$O(n\lg{n})$，还有一些细节，也就不证明了，两者相加时间复杂度为$\Omega(n\lg{n})$

