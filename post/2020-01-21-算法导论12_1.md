---
title: 算法导论12-1
categories: algorithms
---

## 读书笔记

本小节介绍了**二叉搜索树**，二叉搜索树就是左子节点比父节点的值要小，右子节点的值比父节点大的二叉树；这里的小于/大于还包括等于。

```python
INORDER-TREE-WALK(X)
if x != NIL
	INORDER-TREE-WALK(x, left)
	print x.key
	INORDER-TREE-WALK(x, right)
```

上述中序遍历可以从小到大打印二叉搜索树，时间为$\theta(n)$

## 课后习题

### 12.1-1

> 对于关键字集合$<1,4,5,10,16,17,21>$，分别画出高度为$2,3,4,5,6$的二叉搜索树。

分别选用$10,16,17,4,1$作为二叉树的根；

### 12.1-2

> 二叉搜索树性质与最小堆性质之间有什么不同？能使用最小堆性质在$O(n)$时间内按序输出一颗有$n$个结点树的关键字吗？可以的话，请说明如何做，否则解释理由。

最小堆的根是集合中的最小值，而二叉搜索树不是。

二叉搜索树可以不是完全二叉树，最小堆是完全二叉树。

不能，堆排序是基于比较的排序，下限是$O(n\lg{n})$。

### 12.1-3

> 设计一个执行中序遍历的非递归算法。（提示：一种容易的方法是使用栈作为辅助数据结构；另一种较复杂但是比较简洁的做法是不使用栈，但要假设能测试两个指针是否相等。）

请参考[更简单的非递归遍历二叉树的方法](https://www.jianshu.com/p/49c8cfd07410)

```c++
void preorderTraversal(TreeNode *root, vector<int> &path)
{
    stack<TreeNode *> s;
    TreeNode *p = root;
    while(p != NULL || !s.empty())
    {
        while(p != NULL)
        {
            path.push_back(p->val);
            s.push(p);
            p = p->left;
        }
        if(!s.empty())
        {
            p = s.top();
            s.pop();
            p = p->right;
        }
    }
}
```

### 12.1-4

> 对于一个有$n$个节点的树，请设计在$\theta(n)$时间内完成的先序遍历算法和后序遍历算法。

**略**。

### 12.1-5

> 因为在基于比较的排序模型中，完成$n$个元素的排序，其最坏情况下需要$\Omega(n\lg{n})$时间。试证明：任何基于比较的算法从$n$个元素的任意序列中构造二叉搜索树，其最坏情况下需要$\Omega(n\lg{n})$的时间。

题干已经自证了。