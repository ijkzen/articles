---
title: Retrofit原理
categories: Android原理
---

## 概论

虽然`okhttp`很好用，但是开发者所需要关心的细节太多了，所以`square`又开发了`retrofit`简化流程。

`retrofit`主要使用流程如下：

```kotlin
interface GithubService {

    @GET("users/{user}/repos")
    fun listRepos(@Path("user") user: String): Call<List<String>>
}

val retrofit = Retrofit.Builder()
  .baseUrl("https://api.github.com/")
  .build()

val service = retrofit.create(GithubService::class.java)

val repos = service.listRepos("octocat")
```

过程非常简单，但是有一些问题：

1. 如何做到将接口转化为实现类？
2. 如何将`retrofit`调用转化为`okhttp`调用？
3. 如何从注解中获取信息填充到`request`?
4. 如何将`response`转化为相应的实体类？

## 动态代理

现在有`target`这样一个类，`target`有方法`targetFunction`；现在有这样的需求，在不修改`target`类源代码的前提下，在`targetFunction`真正执行之前或者之后添加一些行为；由于不能修改`target`的源代码，所以必须要新建一个类`proxy`，去调用`targetFunction`方法，并且添加行为；

这种设计模式被称为`代理模式`，根据`proxy`字节码文件是否先于编译期存在，分为 **静态代理** 和 **动态代理**；

### 静态代理

`proxy`声明和`target`一样的接口，并且拥有一个`target`字段，然后再接口实现中调用`target`的方法，并添加行为；

具体代码如下:

```kotlin
interface GithubService{
	fun listRepos(user: String): List<String>
}

class Target : GithubService{

    override fun listRepos(user: String): List<String>{
    	return listOf()
    }
}

class Proxy : GithubService{
	private val target = Target()
	
	override fun listRepos(user: String): List<String>{
		println("before invocation")
		val result = target.listRepos(user)
		println("after invocation")
		return result
	}
}
```

### 动态代理

静态代理的`proxy`可以针对每个接口去提供特定实现，